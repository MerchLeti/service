# ETU Shop Service

Этот репозиторий содержит все необходимые материалы для поднятия фронтенд- и бэкенд-части нашего решения.

## Стек

### Фронтенд

| Технология | Задача             |
|------------|--------------------|
| **Vite**   | Сборка приложения  |
| **Vue**    | Фреймворк          |
| **Pinia**  | Менеджер состояний |

### Бэкенд

| Технология     | Задача                                     |
|----------------|--------------------------------------------|
| **Golang**     | Язык разработки, сборка приложения         |
| **PostgreSQL** | База данных                                |

Golang является современным языком разработки бэкенд-приложений. Его компилируемость и строгая типизация позволяют добиться высокой производительности и небольшого размера скомпилированного приложения. На нем можно реализовать как микросервис, который отвечал бы за конкретную область сайта, так и монолитный проект, содержащий в себе все необходимые модули.

В угоду скорости разработки и простоты развертывания был выбран подход с монолитом. Итоговый докер-образ содержит как логическую API-часть, так и статичный HTML+CSS+JS контент.

PostgreSQL была выбрана как одна из реляционных баз данных, обеспечивая более строгий контроль над данными и прекрасно сочетаясь с языком с такой же строгой типизацией.

### Поддержка

| Технология         | Задача                                                       |
|--------------------|--------------------------------------------------------------|
| **Docker**         | Контейнеризация всего проекта                                |
| **GitHub Actions** | Облачная сборка проекта; выполнение миграций на production-сервере |
| **Goose**          | Инструмент миграции базы данных                              |

Для повышения портативности проекта и возможности его запуска на разных платформах был использован Docker. Сборка проходит в три этапа:
1. Сборка бэкенда (стадия `builder`)
2. Сборка фронтенда (стадия `builder_frontend`)
3. Компоновка

Такой подход (multi-stage build) позволил добиться небольшого размера докер-образа, поскольку в него не входит исходный код Go-библиотек (оставшихся на стадии `builder`) и код NodeJS библиотек (оставшихся на стадии `builder_frontend`).

GitHub Actions позволяет автоматизировать сборку и загрузку докер-образа в общедоступный репозиторий. Также в скрипт добавлен отдельный job, выполняющий миграции на production-сервере.

Goose позволяет безболезненно вносить изменения в базу данных (и откатывать их же). В его "распоряжении" находится папка `migrations`. В ней хранятся SQL-скрипты, последовательно выполняя которые, структура базы данных приходит в актуальное состояние.

## Docker-образ

Для запуска Docker-образ может использовать следующие переменные окружения

| Название            | Описание                                   | Значение по умолчанию |
|---------------------|--------------------------------------------|-----------------------|
| `STARTUP`           | **(обязательно)** Команда запуска сервера* |                       |
| `SERVER_PORT`       | Порт, на котором запустится сервер         | `9000`                |
| `POSTGRES_HOST`     | Адрес базы данных**                        | `localhost`           |
| `POSTGRES_PORT`     | Порт базы данных                           | `5432`                |
| `POSTGRES_USER`     | Имя пользователя базы данных               | `shop`                |
| `POSTGRES_PASSWORD` | Пароль пользователя базы данных            | `shop`                |
| `POSTGRES_DB`       | Название базы данных                       | `shop`                |

(*) Эта переменная присутствует только в Production-сборке и добавлен для того, чтобы в менеджерах контейнеров по типу Pterodactyl или Portainer была возможность изменить строку запуска (например, вывести содержимое какого-то файла вместо запуска сервера или параллельный запуск нескольких процессов).\
При использовании Production-сборки, чтобы сервер запустился, нужно явно указать значение `/app` (при необходимости экранировав слэш в начале).\
Если собрать локальную версию проекта, то эта переменная не используется.

(**) Подразумевает наличие работающей базы данных с актуальной схемой. Если база данных доступна из localhost устройства, на котором запускается сервер, то в качестве адреса нужно передать `host.docker.internal` или использовать другой вариант [решения проблемы доступа к хост-машине из контейнера](https://stackoverflow.com/a/24326540).

### Сборка локальной версии
```shell
docker build -t ghcr.io/merchleti/service:dev -f local.Dockerfile .
```

### Запуск из командной строки

#### Production-сборка:
```shell
docker run --env STARTUP='\/app' --env SERVER_PORT=8081 --env POSTGRES_HOST=host.docker.internal -p 8081:8081 -it ghcr.io/merchleti/service:main
```

#### Локальная версия:
```shell
docker run --env STARTUP='\/app' --env SERVER_PORT=8081 --env POSTGRES_HOST=host.docker.internal -p 8081:8081 -it ghcr.io/merchleti/service:dev
```

### Пример docker-compose
```yaml
version: '3.3'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: shop
      POSTGRES_USER: shop
      POSTGRES_PASSWORD: shop
    ports:
      - "5432:5432"
  shop:
    image: ghcr.io/merchleti/service:main
    environment:
      STARTUP: /app
      SERVER_PORT: 8081
      POSTGRES_HOST: postgres
    ports:
      - "8081:8081"
```
